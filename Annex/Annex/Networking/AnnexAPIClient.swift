import Foundation

enum APIError: Error, Sendable {
    case invalidURL
    case unauthorized
    case invalidPin
    case invalidJSON
    case notFound
    case projectNotFound
    case agentNotFound
    case agentAlreadyRunning
    case agentNotRunning
    case missingPrompt
    case missingMessage
    case invalidOrchestrator
    case serverError(String)
    case networkError(Error)
    case decodingError(Error)

    var userMessage: String {
        switch self {
        case .invalidURL: return "Invalid server address"
        case .unauthorized: return "Session expired. Please re-pair."
        case .invalidPin: return "Invalid PIN. Check the code in Clubhouse."
        case .invalidJSON: return "Request error"
        case .notFound: return "Not found"
        case .projectNotFound: return "Project not found"
        case .agentNotFound: return "Agent not found"
        case .agentAlreadyRunning: return "Agent is already running"
        case .agentNotRunning: return "Agent is not running"
        case .missingPrompt: return "Prompt is required"
        case .missingMessage: return "Message is required"
        case .invalidOrchestrator: return "Invalid orchestrator"
        case .serverError(let msg): return msg
        case .networkError: return "Cannot reach server"
        case .decodingError: return "Unexpected server response"
        }
    }
}

final class AnnexAPIClient: Sendable {
    let host: String
    let port: UInt16
    private let session: URLSession

    /// Host formatted for use in URLs (IPv6 addresses wrapped in brackets).
    private nonisolated var urlHost: String {
        if host.contains(":") {
            let escaped = host.replacingOccurrences(of: "%", with: "%25")
            return "[\(escaped)]"
        }
        return host
    }

    nonisolated var baseURL: String { "http://\(urlHost):\(port)" }

    init(host: String, port: UInt16, session: URLSession = .shared) {
        self.host = host
        self.port = port
        self.session = session
    }

    // MARK: - POST /pair

    func pair(pin: String) async throws(APIError) -> PairResponse {
        let url = try makeURL("/pair")
        var request = URLRequest(url: url)
        request.httpMethod = "POST"
        request.setValue("application/json", forHTTPHeaderField: "Content-Type")
        request.httpBody = try? JSONEncoder().encode(["pin": pin])

        let data = try await perform(request)
        return try decode(PairResponse.self, from: data)
    }

    // MARK: - GET /api/v1/status

    func getStatus(token: String) async throws(APIError) -> StatusResponse {
        let url = try makeURL("/api/v1/status")
        var request = URLRequest(url: url)
        request.setValue("Bearer \(token)", forHTTPHeaderField: "Authorization")

        let data = try await perform(request)
        return try decode(StatusResponse.self, from: data)
    }

    // MARK: - GET /api/v1/projects

    func getProjects(token: String) async throws(APIError) -> [Project] {
        let url = try makeURL("/api/v1/projects")
        var request = URLRequest(url: url)
        request.setValue("Bearer \(token)", forHTTPHeaderField: "Authorization")

        let data = try await perform(request)
        return try decode([Project].self, from: data)
    }

    // MARK: - GET /api/v1/projects/{projectId}/agents

    func getAgents(projectId: String, token: String) async throws(APIError) -> [DurableAgent] {
        let url = try makeURL("/api/v1/projects/\(projectId)/agents")
        var request = URLRequest(url: url)
        request.setValue("Bearer \(token)", forHTTPHeaderField: "Authorization")

        let data = try await perform(request)
        return try decode([DurableAgent].self, from: data)
    }

    // MARK: - GET /api/v1/agents/{agentId}/buffer

    func getBuffer(agentId: String, token: String) async throws(APIError) -> String {
        let url = try makeURL("/api/v1/agents/\(agentId)/buffer")
        var request = URLRequest(url: url)
        request.setValue("Bearer \(token)", forHTTPHeaderField: "Authorization")

        let data = try await perform(request)
        return String(data: data, encoding: .utf8) ?? ""
    }

    // MARK: - POST /api/v1/projects/{projectId}/agents/quick

    func spawnQuickAgent(
        projectId: String,
        request: SpawnQuickAgentRequest,
        token: String
    ) async throws(APIError) -> SpawnQuickAgentResponse {
        let url = try makeURL("/api/v1/projects/\(projectId)/agents/quick")
        var req = URLRequest(url: url)
        req.httpMethod = "POST"
        req.setValue("application/json", forHTTPHeaderField: "Content-Type")
        req.setValue("Bearer \(token)", forHTTPHeaderField: "Authorization")
        req.httpBody = try? JSONEncoder().encode(request)

        let data = try await perform(req)
        return try decode(SpawnQuickAgentResponse.self, from: data)
    }

    // MARK: - POST /api/v1/agents/{agentId}/agents/quick

    func spawnQuickAgentUnder(
        parentAgentId: String,
        request: SpawnQuickAgentRequest,
        token: String
    ) async throws(APIError) -> SpawnQuickAgentResponse {
        let url = try makeURL("/api/v1/agents/\(parentAgentId)/agents/quick")
        var req = URLRequest(url: url)
        req.httpMethod = "POST"
        req.setValue("application/json", forHTTPHeaderField: "Content-Type")
        req.setValue("Bearer \(token)", forHTTPHeaderField: "Authorization")
        req.httpBody = try? JSONEncoder().encode(request)

        let data = try await perform(req)
        return try decode(SpawnQuickAgentResponse.self, from: data)
    }

    // MARK: - POST /api/v1/agents/{agentId}/cancel

    func cancelAgent(agentId: String, token: String) async throws(APIError) -> CancelAgentResponse {
        let url = try makeURL("/api/v1/agents/\(agentId)/cancel")
        var req = URLRequest(url: url)
        req.httpMethod = "POST"
        req.setValue("Bearer \(token)", forHTTPHeaderField: "Authorization")

        let data = try await perform(req)
        return try decode(CancelAgentResponse.self, from: data)
    }

    // MARK: - POST /api/v1/agents/{agentId}/wake

    func wakeAgent(
        agentId: String,
        request: WakeAgentRequest,
        token: String
    ) async throws(APIError) -> WakeAgentResponse {
        let url = try makeURL("/api/v1/agents/\(agentId)/wake")
        var req = URLRequest(url: url)
        req.httpMethod = "POST"
        req.setValue("application/json", forHTTPHeaderField: "Content-Type")
        req.setValue("Bearer \(token)", forHTTPHeaderField: "Authorization")
        req.httpBody = try? JSONEncoder().encode(request)

        let data = try await perform(req)
        return try decode(WakeAgentResponse.self, from: data)
    }

    // MARK: - POST /api/v1/agents/{agentId}/message

    func sendMessage(
        agentId: String,
        request: SendMessageRequest,
        token: String
    ) async throws(APIError) -> SendMessageResponse {
        let url = try makeURL("/api/v1/agents/\(agentId)/message")
        var req = URLRequest(url: url)
        req.httpMethod = "POST"
        req.setValue("application/json", forHTTPHeaderField: "Content-Type")
        req.setValue("Bearer \(token)", forHTTPHeaderField: "Authorization")
        req.httpBody = try? JSONEncoder().encode(request)

        let data = try await perform(req)
        return try decode(SendMessageResponse.self, from: data)
    }

    // MARK: - GET /api/v1/icons/agent/{agentId}

    func fetchAgentIcon(agentId: String, token: String) async -> Data? {
        guard let url = try? makeURL("/api/v1/icons/agent/\(agentId)") else { return nil }
        var req = URLRequest(url: url)
        req.setValue("Bearer \(token)", forHTTPHeaderField: "Authorization")
        guard let (data, response) = try? await session.data(for: req),
              let http = response as? HTTPURLResponse,
              http.statusCode == 200 else { return nil }
        return data
    }

    // MARK: - GET /api/v1/icons/project/{projectId}

    func fetchProjectIcon(projectId: String, token: String) async -> Data? {
        guard let url = try? makeURL("/api/v1/icons/project/\(projectId)") else { return nil }
        var req = URLRequest(url: url)
        req.setValue("Bearer \(token)", forHTTPHeaderField: "Authorization")
        guard let (data, response) = try? await session.data(for: req),
              let http = response as? HTTPURLResponse,
              http.statusCode == 200 else { return nil }
        return data
    }

    // MARK: - WebSocket URL

    func webSocketURL(token: String) throws(APIError) -> URL {
        guard let url = URL(string: "ws://\(urlHost):\(port)/ws?token=\(token)") else {
            throw .invalidURL
        }
        return url
    }

    // MARK: - Helpers

    private func makeURL(_ path: String) throws(APIError) -> URL {
        guard let url = URL(string: "\(baseURL)\(path)") else {
            throw .invalidURL
        }
        return url
    }

    private nonisolated func perform(_ request: URLRequest) async throws(APIError) -> Data {
        let data: Data
        let response: URLResponse
        do {
            (data, response) = try await session.data(for: request)
        } catch {
            throw .networkError(error)
        }

        guard let http = response as? HTTPURLResponse else {
            throw .networkError(URLError(.badServerResponse))
        }

        switch http.statusCode {
        case 200, 201:
            return data
        case 401:
            if let errResp = try? JSONDecoder().decode(ErrorResponse.self, from: data) {
                if errResp.error == "invalid_pin" { throw .invalidPin }
            }
            throw .unauthorized
        case 400:
            if let errResp = try? JSONDecoder().decode(ErrorResponse.self, from: data) {
                switch errResp.error {
                case "missing_prompt": throw .missingPrompt
                case "missing_message": throw .missingMessage
                case "invalid_orchestrator": throw .invalidOrchestrator
                default: break
                }
            }
            throw .invalidJSON
        case 404:
            if let errResp = try? JSONDecoder().decode(ErrorResponse.self, from: data) {
                switch errResp.error {
                case "project_not_found": throw .projectNotFound
                case "agent_not_found": throw .agentNotFound
                default: break
                }
            }
            throw .notFound
        case 409:
            if let errResp = try? JSONDecoder().decode(ErrorResponse.self, from: data) {
                switch errResp.error {
                case "agent_already_running": throw .agentAlreadyRunning
                case "agent_not_running": throw .agentNotRunning
                default: break
                }
            }
            throw .serverError("Conflict")
        default:
            if let errResp = try? JSONDecoder().decode(ErrorResponse.self, from: data) {
                throw .serverError(errResp.error)
            }
            throw .serverError("HTTP \(http.statusCode)")
        }
    }

    private func decode<T: Decodable>(_ type: T.Type, from data: Data) throws(APIError) -> T {
        do {
            return try JSONDecoder().decode(type, from: data)
        } catch {
            throw .decodingError(error)
        }
    }
}
